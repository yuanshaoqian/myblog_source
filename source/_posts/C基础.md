---
title: C基础
date: 2019-02-23 21:00:32
tags: C语言
---

##编写简单的C程序HelloWorld
```C
#include<stdio.h>
int main()
{
	printf("Hello World!\n");
	return 0;
}
```

程序讲解：

```C
#include<stdio.h>//标准I/O头文件，下文中的printf需要使用这个文件
main()//主函数，一个程序的入口。一个程序有且只有一个main()函数
int//代表主函数的返回值类型是int型
printf()//格式化输出，将括号内的内容打印到显示器上，打印字符串需要用双引号""引上
return 0;//配合主函数类型使用，一般来说返回0的程序表示程序运行成功
```

编译器GCC：把程序代码变成可执行程序
XXXX.c变成可执行程序步骤：
⒈gcc XXXX.c -o XXXX
-o的作用：生成的产物的名字
⒉如果不加-o和名字，则默认生成a.out文件
gcc XXXX.c
则生成为a.out
⒊make XXXX
等价于gcc XXXX.c -o XXXX

执行该程序：
./XXXX（./a.out）


### C语言从代码变成可执行程序的步骤：

> 预处理 -----> 编译 -----> 汇编 -----> 链接

<font size="5">
⒈预处理：去掉注释，加载头文件，代替宏定义，条件编译
所需文件：.c文件
生成文件以.i结尾
使用方法：gcc XXXX.c -E -o XXXX.i
⒉编译：使用编译器进行C语言的语法检查，如果有语法错误，报错，并结束编译过程;如果没有语法错误，把C的源程序转变为汇编代码
需要文件：.i文件
生成产物：汇编文件（以.s结尾）
使用方法：gcc XXXX.i -S -o XXXX.s
可以使用vim打开汇编文件来查看生成产物
⒊汇编：把汇编源文件通过汇编器生成目标文件（二进制机器语言）
需要文件：.s文件
生成产物：机器码（或称为“目标代码”，以.o结尾）
使用方法：gcc XXXX.s -c -o XXXX.o
可以使用vim打开目标代码文件来查看生成产物（不过只会看到乱码）
⒋链接：把目标文件执行所依赖的所有二进制的其他目标文件及C的库文件都整合成一个可执行文件的过程
需要文件：.o文件及各种动态库或静态库
生成产物：可执行程序
使用方法：gcc XXXX.o -o XXXX
-o：指定生成的产物的名字
-Wall：让编译器报告全部错误
通常使用
gcc XXXX.c -o hello -Wall
编译完成后（无error，无warning），会生成-o之后的文件（如没有加-o则会生成a.out文件）
执行文件：
./XXXX（./a.out）</font>

---------

<font size="5">
```C
1、基本数据类型
void：声明函数无返回值或无参数，声明无类型指针，显示丢弃运算结果。（C89标准新增）
char：字符型类型数据，属于整型数据的一种。（K&R时期引入）
int：整型数据，表示范围通常为编译器指定的内存字节长。（K&R时期引入）
float：单精度浮点型数据，属于浮点数据的一种。（K&R时期引入）
double：双精度浮点型数据，属于浮点数据的一种。（K&R时期引入）
//_Bool:布尔型（C99标准新增）
//_Complex:复数的基本类型（C99标准新增）
//_Imaginary:虚数，与复数基本类型相似，没有实部的纯虚数（C99标准新增）
//_Generic:提供重载的接口入口（C11标准新增）
2、类型修饰关键字
short：修饰int，短整型数据，可省略被修饰的int。（K&R时期引入）
long：修饰int，长整型数据，可省略被修饰的int。（K&R时期引入）
//long long：修饰int，超长整型数据，可省略被修饰的int。（C99标准新增）
signed：修饰整型数据，有符号数据类型。（C89标准新增）
unsigned：修饰整型数据，无符号数据类型。（K&R时期引入）
//restrict:用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式。（C99标准新增）
3、复杂类型关键字
struct：结构体声明。（K&R时期引入）
union：联合体声明。（K&R时期引入）
enum：枚举声明。（C89标准新增）
typedef：声明类型别名。（K&R时期引入）
sizeof：得到特定类型或特定类型变量的大小。（K&R时期引入）
//inline:内联函数用于取代宏定义，会在任何调用它的地方展开。（C99标准新增）
4、存储级别关键字
auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配。与static相反。当变量未指定时默认为auto。（K&R时期引入）
static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。（K&R时期引入）
register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数。（K&R时期引入）
extern：指定对应变量为外部变量，即标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。（K&R时期引入）
const：指定变量不可被当前线程改变（但有可能被系统或其他线程改变）。（C89标准新增）
volatile：指定变量的值有可能会被系统或其他线程改变，强制编译器每次从内存中取得该变量的值，阻止编译器把该变量优化成寄存器变量。（C89标准新增）
5、流程控制关键字
1）跳转结构
return：用在函数体中，返回特定值（如果是void类型，则不返回函数值）。（K&R时期引入）
continue：结束当前循环，开始下一轮循环。（K&R时期引入）
break：跳出当前循环或switch结构。（K&R时期引入）
goto：无条件跳转语句。（K&R时期引入）
2）分支结构
if：条件语句，后面不需要放分号。（K&R时期引入）
else：条件语句否定分支（必须与if连用）。（K&R时期引入）
switch：开关语句（多重分支语句）。（K&R时期引入）
case：开关语句中的分支标记，与switch连用。（K&R时期引入）
default：开关语句中的“其他”分支，可选。（K&R时期引入）
for：循环（K&R时期引入）
while：循环（K&R时期引入）
```
<font>
